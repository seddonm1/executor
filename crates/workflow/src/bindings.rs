// Generated by `wit-bindgen` 0.25.0. DO NOT EDIT!
// Options used:
//   * pub-export-macro
pub type GuestToHost = component::workflow::abi::GuestToHost;
pub type HostToGuest = component::workflow::abi::HostToGuest;
pub type WorkflowError = component::workflow::abi::WorkflowError;
#[allow(unused_unsafe, clippy::all)]
pub fn call(input: &GuestToHost) -> HostToGuest {
    unsafe {
        let mut cleanup_list = _rt::Vec::new();
        #[repr(align(8))]
        struct RetArea([::core::mem::MaybeUninit<u8>; 72]);
        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 72]);
        use component::workflow::abi::GuestToHost as V18;
        let (
            result19_0,
            result19_1,
            result19_2,
            result19_3,
            result19_4,
            result19_5,
            result19_6,
            result19_7,
            result19_8,
        ) = match input {
            V18::Input => (
                0i32,
                0i32,
                ::core::ptr::null_mut(),
                ::core::ptr::null_mut(),
                0usize,
                ::core::ptr::null_mut(),
                0usize,
                ::core::ptr::null_mut(),
                0usize,
            ),
            V18::Random(e) => {
                use component::workflow::abi::Types as V1;
                let (result2_0, result2_1, result2_2) = match e {
                    V1::BoolType(e) => (
                        0i32,
                        match e {
                            true => 1,
                            false => 0,
                        } as *mut u8,
                        0usize,
                    ),
                    V1::I32Type(e) => (1i32, _rt::as_i32(e) as *mut u8, 0usize),
                    V1::F32Type(e) => (2i32, (_rt::as_f32(e)).to_bits() as i32 as *mut u8, 0usize),
                    V1::StringType(e) => {
                        let vec0 = e;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();

                        (3i32, ptr0.cast_mut(), len0)
                    }
                };

                (
                    1i32,
                    result2_0,
                    result2_1,
                    result2_2 as *mut u8,
                    0usize,
                    ::core::ptr::null_mut(),
                    0usize,
                    ::core::ptr::null_mut(),
                    0usize,
                )
            }
            V18::Time => (
                2i32,
                0i32,
                ::core::ptr::null_mut(),
                ::core::ptr::null_mut(),
                0usize,
                ::core::ptr::null_mut(),
                0usize,
                ::core::ptr::null_mut(),
                0usize,
            ),
            V18::HttpRequest(e) => {
                let component::workflow::http::Request {
                    method: method3,
                    body: body3,
                    path: path3,
                    headers: headers3,
                } = e;
                let (result5_0, result5_1, result5_2) = match body3 {
                    Some(e) => {
                        let vec4 = e;
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();

                        (1i32, ptr4.cast_mut(), len4)
                    }
                    None => (0i32, ::core::ptr::null_mut(), 0usize),
                };
                let vec6 = path3;
                let ptr6 = vec6.as_ptr().cast::<u8>();
                let len6 = vec6.len();
                let vec10 = headers3;
                let len10 = vec10.len();
                let layout10 = _rt::alloc::Layout::from_size_align_unchecked(vec10.len() * 16, 4);
                let result10 = if layout10.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout10).cast::<u8>();
                    if ptr.is_null() {
                        _rt::alloc::handle_alloc_error(layout10);
                    }
                    ptr
                } else {
                    {
                        ::core::ptr::null_mut()
                    }
                };
                for (i, e) in vec10.into_iter().enumerate() {
                    let base = result10.add(i * 16);
                    {
                        let component::workflow::http::Header {
                            key: key7,
                            value: value7,
                        } = e;
                        let vec8 = key7;
                        let ptr8 = vec8.as_ptr().cast::<u8>();
                        let len8 = vec8.len();
                        *base.add(4).cast::<usize>() = len8;
                        *base.add(0).cast::<*mut u8>() = ptr8.cast_mut();
                        let vec9 = value7;
                        let ptr9 = vec9.as_ptr().cast::<u8>();
                        let len9 = vec9.len();
                        *base.add(12).cast::<usize>() = len9;
                        *base.add(8).cast::<*mut u8>() = ptr9.cast_mut();
                    }
                }
                cleanup_list.extend_from_slice(&[(result10, layout10)]);

                (
                    3i32,
                    method3.clone() as i32,
                    result5_0 as *mut u8,
                    result5_1,
                    result5_2,
                    ptr6.cast_mut(),
                    len6,
                    result10,
                    len10,
                )
            }
            V18::Log(e) => {
                use component::workflow::abi::Level as V16;
                let (result17_0, result17_1, result17_2) = match e {
                    V16::Trace(e) => {
                        let vec11 = e;
                        let ptr11 = vec11.as_ptr().cast::<u8>();
                        let len11 = vec11.len();

                        (0i32, ptr11.cast_mut(), len11)
                    }
                    V16::Debug(e) => {
                        let vec12 = e;
                        let ptr12 = vec12.as_ptr().cast::<u8>();
                        let len12 = vec12.len();

                        (1i32, ptr12.cast_mut(), len12)
                    }
                    V16::Info(e) => {
                        let vec13 = e;
                        let ptr13 = vec13.as_ptr().cast::<u8>();
                        let len13 = vec13.len();

                        (2i32, ptr13.cast_mut(), len13)
                    }
                    V16::Warn(e) => {
                        let vec14 = e;
                        let ptr14 = vec14.as_ptr().cast::<u8>();
                        let len14 = vec14.len();

                        (3i32, ptr14.cast_mut(), len14)
                    }
                    V16::Error(e) => {
                        let vec15 = e;
                        let ptr15 = vec15.as_ptr().cast::<u8>();
                        let len15 = vec15.len();

                        (4i32, ptr15.cast_mut(), len15)
                    }
                };

                (
                    4i32,
                    result17_0,
                    result17_1,
                    result17_2 as *mut u8,
                    0usize,
                    ::core::ptr::null_mut(),
                    0usize,
                    ::core::ptr::null_mut(),
                    0usize,
                )
            }
        };
        let ptr20 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        extern "C" {
            #[link_name = "call"]
            fn wit_import(
                _: i32,
                _: i32,
                _: *mut u8,
                _: *mut u8,
                _: usize,
                _: *mut u8,
                _: usize,
                _: *mut u8,
                _: usize,
                _: *mut u8,
            );
        }

        #[cfg(not(target_arch = "wasm32"))]
        fn wit_import(
            _: i32,
            _: i32,
            _: *mut u8,
            _: *mut u8,
            _: usize,
            _: *mut u8,
            _: usize,
            _: *mut u8,
            _: usize,
            _: *mut u8,
        ) {
            unreachable!()
        }
        wit_import(
            result19_0, result19_1, result19_2, result19_3, result19_4, result19_5, result19_6,
            result19_7, result19_8, ptr20,
        );
        let l21 = *ptr20.add(0).cast::<*mut u8>();
        let l22 = *ptr20.add(4).cast::<usize>();
        let len23 = l22;
        let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);
        let l24 = i32::from(*ptr20.add(8).cast::<u8>());
        use component::workflow::abi::Content as V72;
        let v72 = match l24 {
            0 => V72::Unit,
            1 => {
                let e72 = {
                    let l25 = i32::from(*ptr20.add(16).cast::<u8>());
                    use component::workflow::abi::Types as V32;
                    let v32 = match l25 {
                        0 => {
                            let e32 = {
                                let l26 = i32::from(*ptr20.add(20).cast::<u8>());

                                _rt::bool_lift(l26 as u8)
                            };
                            V32::BoolType(e32)
                        }
                        1 => {
                            let e32 = {
                                let l27 = *ptr20.add(20).cast::<i32>();

                                l27 as u32
                            };
                            V32::I32Type(e32)
                        }
                        2 => {
                            let e32 = {
                                let l28 = *ptr20.add(20).cast::<f32>();

                                l28
                            };
                            V32::F32Type(e32)
                        }
                        n => {
                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                            let e32 = {
                                let l29 = *ptr20.add(20).cast::<*mut u8>();
                                let l30 = *ptr20.add(24).cast::<usize>();
                                let len31 = l30;
                                let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                                _rt::string_lift(bytes31)
                            };
                            V32::StringType(e32)
                        }
                    };

                    v32
                };
                V72::Random(e72)
            }
            2 => {
                let e72 = {
                    let l33 = i32::from(*ptr20.add(16).cast::<u8>());
                    use component::workflow::abi::Types as V40;
                    let v40 = match l33 {
                        0 => {
                            let e40 = {
                                let l34 = i32::from(*ptr20.add(20).cast::<u8>());

                                _rt::bool_lift(l34 as u8)
                            };
                            V40::BoolType(e40)
                        }
                        1 => {
                            let e40 = {
                                let l35 = *ptr20.add(20).cast::<i32>();

                                l35 as u32
                            };
                            V40::I32Type(e40)
                        }
                        2 => {
                            let e40 = {
                                let l36 = *ptr20.add(20).cast::<f32>();

                                l36
                            };
                            V40::F32Type(e40)
                        }
                        n => {
                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                            let e40 = {
                                let l37 = *ptr20.add(20).cast::<*mut u8>();
                                let l38 = *ptr20.add(24).cast::<usize>();
                                let len39 = l38;
                                let bytes39 = _rt::Vec::from_raw_parts(l37.cast(), len39, len39);

                                _rt::string_lift(bytes39)
                            };
                            V40::StringType(e40)
                        }
                    };

                    v40
                };
                V72::Value(e72)
            }
            3 => {
                let e72 = {
                    let l41 = i32::from(*ptr20.add(16).cast::<u8>());

                    match l41 {
                        0 => {
                            let e = {
                                let l42 = i32::from(*ptr20.add(24).cast::<u16>());
                                let l43 = i32::from(*ptr20.add(26).cast::<u8>());
                                use component::workflow::http::Version as V44;
                                let v44 = match l43 {
                                    0 => V44::HttpZeroNine,
                                    1 => V44::HttpOneZero,
                                    2 => V44::HttpOneOne,
                                    3 => V44::HttpTwoZero,
                                    n => {
                                        debug_assert_eq!(n, 4, "invalid enum discriminant");
                                        V44::HttpThreeZero
                                    }
                                };
                                let l45 = *ptr20.add(28).cast::<*mut u8>();
                                let l46 = *ptr20.add(32).cast::<usize>();
                                let base53 = l45;
                                let len53 = l46;
                                let mut result53 = _rt::Vec::with_capacity(len53);
                                for i in 0..len53 {
                                    let base = base53.add(i * 16);
                                    let e53 = {
                                        let l47 = *base.add(0).cast::<*mut u8>();
                                        let l48 = *base.add(4).cast::<usize>();
                                        let len49 = l48;
                                        let bytes49 =
                                            _rt::Vec::from_raw_parts(l47.cast(), len49, len49);
                                        let l50 = *base.add(8).cast::<*mut u8>();
                                        let l51 = *base.add(12).cast::<usize>();
                                        let len52 = l51;
                                        let bytes52 =
                                            _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                                        component::workflow::http::Header {
                                            key: _rt::string_lift(bytes49),
                                            value: _rt::string_lift(bytes52),
                                        }
                                    };
                                    result53.push(e53);
                                }
                                _rt::cabi_dealloc(base53, len53 * 16, 4);
                                let l54 = i32::from(*ptr20.add(40).cast::<u8>());
                                let l56 = *ptr20.add(56).cast::<*mut u8>();
                                let l57 = *ptr20.add(60).cast::<usize>();
                                let len58 = l57;
                                let bytes58 = _rt::Vec::from_raw_parts(l56.cast(), len58, len58);
                                let l59 = *ptr20.add(64).cast::<*mut u8>();
                                let l60 = *ptr20.add(68).cast::<usize>();
                                let len61 = l60;

                                component::workflow::http::Response {
                                    status: l42 as u16,
                                    http_version: v44,
                                    headers: result53,
                                    content_length: match l54 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l55 = *ptr20.add(48).cast::<i64>();

                                                l55 as u64
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    url: _rt::string_lift(bytes58),
                                    body: _rt::Vec::from_raw_parts(l59.cast(), len61, len61),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l62 = i32::from(*ptr20.add(24).cast::<u8>());
                                let l66 = i32::from(*ptr20.add(36).cast::<u8>());

                                component::workflow::http::Error {
                                    url: match l62 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l63 = *ptr20.add(28).cast::<*mut u8>();
                                                let l64 = *ptr20.add(32).cast::<usize>();
                                                let len65 = l64;
                                                let bytes65 = _rt::Vec::from_raw_parts(
                                                    l63.cast(),
                                                    len65,
                                                    len65,
                                                );

                                                _rt::string_lift(bytes65)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    kind: match l66 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l67 = i32::from(*ptr20.add(38).cast::<u8>());
                                                use component::workflow::http::Kind as V69;
                                                let v69 = match l67 {
                                                    0 => V69::Builder,
                                                    1 => V69::Request,
                                                    2 => V69::Redirect,
                                                    3 => {
                                                        let e69 = {
                                                            let l68 = i32::from(
                                                                *ptr20.add(40).cast::<u16>(),
                                                            );

                                                            l68 as u16
                                                        };
                                                        V69::Status(e69)
                                                    }
                                                    4 => V69::Body,
                                                    5 => V69::Decode,
                                                    n => {
                                                        debug_assert_eq!(
                                                            n, 6,
                                                            "invalid enum discriminant"
                                                        );
                                                        V69::Upgrade
                                                    }
                                                };

                                                v69
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                };
                V72::HttpResponse(e72)
            }
            n => {
                debug_assert_eq!(n, 4, "invalid enum discriminant");
                let e72 = {
                    let l70 = *ptr20.add(16).cast::<i64>();
                    let l71 = *ptr20.add(24).cast::<i32>();

                    component::workflow::abi::SystemTime {
                        tv_sec: l70 as u64,
                        tv_nsec: l71 as u32,
                    }
                };
                V72::Time(e72)
            }
        };
        for (ptr, layout) in cleanup_list {
            if layout.size() != 0 {
                _rt::alloc::dealloc(ptr.cast(), layout);
            }
        }
        component::workflow::abi::HostToGuest {
            id: _rt::string_lift(bytes23),
            content: v72,
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_execute_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    let result0 = T::execute();
    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result0 {
        Ok(_) => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
        }
        Err(e) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
            let component::workflow::abi::WorkflowError {
                id: id2,
                error: error2,
            } = e;
            match id2 {
                Some(e) => {
                    *ptr1.add(4).cast::<u8>() = (1i32) as u8;
                    let vec3 = (e.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(12).cast::<usize>() = len3;
                    *ptr1.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                }
                None => {
                    *ptr1.add(4).cast::<u8>() = (0i32) as u8;
                }
            };
            let vec4 = (error2.into_bytes()).into_boxed_slice();
            let ptr4 = vec4.as_ptr().cast::<u8>();
            let len4 = vec4.len();
            ::core::mem::forget(vec4);
            *ptr1.add(20).cast::<usize>() = len4;
            *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_execute<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => (),
        _ => {
            let l1 = i32::from(*arg0.add(4).cast::<u8>());
            match l1 {
                0 => (),
                _ => {
                    let l2 = *arg0.add(8).cast::<*mut u8>();
                    let l3 = *arg0.add(12).cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                }
            }
            let l4 = *arg0.add(16).cast::<*mut u8>();
            let l5 = *arg0.add(20).cast::<usize>();
            _rt::cabi_dealloc(l4, l5, 1);
        }
    }
}
pub trait Guest {
    fn execute() -> Result<(), WorkflowError>;
}
#[doc(hidden)]
#[macro_export]
macro_rules! __export_world_workflow_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "execute"]
    unsafe extern "C" fn export_execute() -> *mut u8 {
      $($path_to_types)*::_export_execute_cabi::<$ty>()
    }
    #[export_name = "cabi_post_execute"]
    unsafe extern "C" fn _post_return_execute(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_execute::<$ty>(arg0)
    }
  };);
}
#[doc(hidden)]
pub use __export_world_workflow_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
#[allow(dead_code)]
pub mod component {
    #[allow(dead_code)]
    pub mod workflow {
        #[allow(dead_code, clippy::all)]
        pub mod http {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum Method {
                Get,
                Post,
                Delete,
            }
            impl ::core::fmt::Debug for Method {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Method::Get => f.debug_tuple("Method::Get").finish(),
                        Method::Post => f.debug_tuple("Method::Post").finish(),
                        Method::Delete => f.debug_tuple("Method::Delete").finish(),
                    }
                }
            }

            impl Method {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Method {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => Method::Get,
                        1 => Method::Post,
                        2 => Method::Delete,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone)]
            pub struct Header {
                pub key: _rt::String,
                pub value: _rt::String,
            }
            impl ::core::fmt::Debug for Header {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Header")
                        .field("key", &self.key)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Request {
                pub method: Method,
                pub body: Option<_rt::Vec<u8>>,
                pub path: _rt::String,
                pub headers: _rt::Vec<Header>,
            }
            impl ::core::fmt::Debug for Request {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Request")
                        .field("method", &self.method)
                        .field("body", &self.body)
                        .field("path", &self.path)
                        .field("headers", &self.headers)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum Version {
                HttpZeroNine,
                HttpOneZero,
                HttpOneOne,
                HttpTwoZero,
                HttpThreeZero,
            }
            impl ::core::fmt::Debug for Version {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Version::HttpZeroNine => f.debug_tuple("Version::HttpZeroNine").finish(),
                        Version::HttpOneZero => f.debug_tuple("Version::HttpOneZero").finish(),
                        Version::HttpOneOne => f.debug_tuple("Version::HttpOneOne").finish(),
                        Version::HttpTwoZero => f.debug_tuple("Version::HttpTwoZero").finish(),
                        Version::HttpThreeZero => f.debug_tuple("Version::HttpThreeZero").finish(),
                    }
                }
            }
            #[derive(Clone)]
            pub struct Response {
                pub status: u16,
                pub http_version: Version,
                pub headers: _rt::Vec<Header>,
                pub content_length: Option<u64>,
                pub url: _rt::String,
                pub body: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for Response {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Response")
                        .field("status", &self.status)
                        .field("http-version", &self.http_version)
                        .field("headers", &self.headers)
                        .field("content-length", &self.content_length)
                        .field("url", &self.url)
                        .field("body", &self.body)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum Kind {
                Builder,
                Request,
                Redirect,
                Status(u16),
                Body,
                Decode,
                Upgrade,
            }
            impl ::core::fmt::Debug for Kind {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Kind::Builder => f.debug_tuple("Kind::Builder").finish(),
                        Kind::Request => f.debug_tuple("Kind::Request").finish(),
                        Kind::Redirect => f.debug_tuple("Kind::Redirect").finish(),
                        Kind::Status(e) => f.debug_tuple("Kind::Status").field(e).finish(),
                        Kind::Body => f.debug_tuple("Kind::Body").finish(),
                        Kind::Decode => f.debug_tuple("Kind::Decode").finish(),
                        Kind::Upgrade => f.debug_tuple("Kind::Upgrade").finish(),
                    }
                }
            }
            #[derive(Clone)]
            pub struct Error {
                pub url: Option<_rt::String>,
                pub kind: Option<Kind>,
            }
            impl ::core::fmt::Debug for Error {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Error")
                        .field("url", &self.url)
                        .field("kind", &self.kind)
                        .finish()
                }
            }
        }

        #[allow(dead_code, clippy::all)]
        pub mod abi {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Request = super::super::super::component::workflow::http::Request;
            pub type Response = super::super::super::component::workflow::http::Response;
            pub type Error = super::super::super::component::workflow::http::Error;
            #[derive(Clone)]
            pub enum Types {
                BoolType(bool),
                I32Type(u32),
                F32Type(f32),
                StringType(_rt::String),
            }
            impl ::core::fmt::Debug for Types {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Types::BoolType(e) => f.debug_tuple("Types::BoolType").field(e).finish(),
                        Types::I32Type(e) => f.debug_tuple("Types::I32Type").field(e).finish(),
                        Types::F32Type(e) => f.debug_tuple("Types::F32Type").field(e).finish(),
                        Types::StringType(e) => {
                            f.debug_tuple("Types::StringType").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum Level {
                Trace(_rt::String),
                Debug(_rt::String),
                Info(_rt::String),
                Warn(_rt::String),
                Error(_rt::String),
            }
            impl ::core::fmt::Debug for Level {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Level::Trace(e) => f.debug_tuple("Level::Trace").field(e).finish(),
                        Level::Debug(e) => f.debug_tuple("Level::Debug").field(e).finish(),
                        Level::Info(e) => f.debug_tuple("Level::Info").field(e).finish(),
                        Level::Warn(e) => f.debug_tuple("Level::Warn").field(e).finish(),
                        Level::Error(e) => f.debug_tuple("Level::Error").field(e).finish(),
                    }
                }
            }
            #[derive(Clone)]
            pub enum GuestToHost {
                Input,
                Random(Types),
                Time,
                HttpRequest(Request),
                Log(Level),
            }
            impl ::core::fmt::Debug for GuestToHost {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        GuestToHost::Input => f.debug_tuple("GuestToHost::Input").finish(),
                        GuestToHost::Random(e) => {
                            f.debug_tuple("GuestToHost::Random").field(e).finish()
                        }
                        GuestToHost::Time => f.debug_tuple("GuestToHost::Time").finish(),
                        GuestToHost::HttpRequest(e) => {
                            f.debug_tuple("GuestToHost::HttpRequest").field(e).finish()
                        }
                        GuestToHost::Log(e) => f.debug_tuple("GuestToHost::Log").field(e).finish(),
                    }
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct SystemTime {
                pub tv_sec: u64,
                pub tv_nsec: u32,
            }
            impl ::core::fmt::Debug for SystemTime {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("SystemTime")
                        .field("tv-sec", &self.tv_sec)
                        .field("tv-nsec", &self.tv_nsec)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum Content {
                Unit,
                Random(Types),
                Value(Types),
                HttpResponse(Result<Response, Error>),
                Time(SystemTime),
            }
            impl ::core::fmt::Debug for Content {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Content::Unit => f.debug_tuple("Content::Unit").finish(),
                        Content::Random(e) => f.debug_tuple("Content::Random").field(e).finish(),
                        Content::Value(e) => f.debug_tuple("Content::Value").field(e).finish(),
                        Content::HttpResponse(e) => {
                            f.debug_tuple("Content::HttpResponse").field(e).finish()
                        }
                        Content::Time(e) => f.debug_tuple("Content::Time").field(e).finish(),
                    }
                }
            }
            #[derive(Clone)]
            pub struct HostToGuest {
                pub id: _rt::String,
                pub content: Content,
            }
            impl ::core::fmt::Debug for HostToGuest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("HostToGuest")
                        .field("id", &self.id)
                        .field("content", &self.content)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkflowError {
                pub id: Option<_rt::String>,
                pub error: _rt::String,
            }
            impl ::core::fmt::Debug for WorkflowError {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkflowError")
                        .field("id", &self.id)
                        .field("error", &self.error)
                        .finish()
                }
            }
            impl ::core::fmt::Display for WorkflowError {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for WorkflowError {}
        }
    }
}
#[allow(dead_code)]
pub mod exports {
    #[allow(dead_code)]
    pub mod component {
        #[allow(dead_code)]
        pub mod workflow {
            #[allow(dead_code, clippy::all)]
            pub mod http {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum Method {
                    Get,
                    Post,
                    Delete,
                }
                impl ::core::fmt::Debug for Method {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Method::Get => f.debug_tuple("Method::Get").finish(),
                            Method::Post => f.debug_tuple("Method::Post").finish(),
                            Method::Delete => f.debug_tuple("Method::Delete").finish(),
                        }
                    }
                }

                impl Method {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Method {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => Method::Get,
                            1 => Method::Post,
                            2 => Method::Delete,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[derive(Clone)]
                pub struct Header {
                    pub key: _rt::String,
                    pub value: _rt::String,
                }
                impl ::core::fmt::Debug for Header {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Header")
                            .field("key", &self.key)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct Request {
                    pub method: Method,
                    pub body: Option<_rt::Vec<u8>>,
                    pub path: _rt::String,
                    pub headers: _rt::Vec<Header>,
                }
                impl ::core::fmt::Debug for Request {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Request")
                            .field("method", &self.method)
                            .field("body", &self.body)
                            .field("path", &self.path)
                            .field("headers", &self.headers)
                            .finish()
                    }
                }
                #[derive(Clone, Copy)]
                pub enum Version {
                    HttpZeroNine,
                    HttpOneZero,
                    HttpOneOne,
                    HttpTwoZero,
                    HttpThreeZero,
                }
                impl ::core::fmt::Debug for Version {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Version::HttpZeroNine => {
                                f.debug_tuple("Version::HttpZeroNine").finish()
                            }
                            Version::HttpOneZero => f.debug_tuple("Version::HttpOneZero").finish(),
                            Version::HttpOneOne => f.debug_tuple("Version::HttpOneOne").finish(),
                            Version::HttpTwoZero => f.debug_tuple("Version::HttpTwoZero").finish(),
                            Version::HttpThreeZero => {
                                f.debug_tuple("Version::HttpThreeZero").finish()
                            }
                        }
                    }
                }
                #[derive(Clone)]
                pub struct Response {
                    pub status: u16,
                    pub http_version: Version,
                    pub headers: _rt::Vec<Header>,
                    pub content_length: Option<u64>,
                    pub url: _rt::String,
                    pub body: _rt::Vec<u8>,
                }
                impl ::core::fmt::Debug for Response {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Response")
                            .field("status", &self.status)
                            .field("http-version", &self.http_version)
                            .field("headers", &self.headers)
                            .field("content-length", &self.content_length)
                            .field("url", &self.url)
                            .field("body", &self.body)
                            .finish()
                    }
                }
                #[derive(Clone, Copy)]
                pub enum Kind {
                    Builder,
                    Request,
                    Redirect,
                    Status(u16),
                    Body,
                    Decode,
                    Upgrade,
                }
                impl ::core::fmt::Debug for Kind {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Kind::Builder => f.debug_tuple("Kind::Builder").finish(),
                            Kind::Request => f.debug_tuple("Kind::Request").finish(),
                            Kind::Redirect => f.debug_tuple("Kind::Redirect").finish(),
                            Kind::Status(e) => f.debug_tuple("Kind::Status").field(e).finish(),
                            Kind::Body => f.debug_tuple("Kind::Body").finish(),
                            Kind::Decode => f.debug_tuple("Kind::Decode").finish(),
                            Kind::Upgrade => f.debug_tuple("Kind::Upgrade").finish(),
                        }
                    }
                }
                #[derive(Clone)]
                pub struct Error {
                    pub url: Option<_rt::String>,
                    pub kind: Option<Kind>,
                }
                impl ::core::fmt::Debug for Error {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Error")
                            .field("url", &self.url)
                            .field("kind", &self.kind)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_component_workflow_http_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub use __export_component_workflow_http_cabi;
            }

            #[allow(dead_code, clippy::all)]
            pub mod abi {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Request =
                    super::super::super::super::exports::component::workflow::http::Request;
                pub type Response =
                    super::super::super::super::exports::component::workflow::http::Response;
                pub type Error =
                    super::super::super::super::exports::component::workflow::http::Error;
                #[derive(Clone)]
                pub enum Types {
                    BoolType(bool),
                    I32Type(u32),
                    F32Type(f32),
                    StringType(_rt::String),
                }
                impl ::core::fmt::Debug for Types {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Types::BoolType(e) => {
                                f.debug_tuple("Types::BoolType").field(e).finish()
                            }
                            Types::I32Type(e) => f.debug_tuple("Types::I32Type").field(e).finish(),
                            Types::F32Type(e) => f.debug_tuple("Types::F32Type").field(e).finish(),
                            Types::StringType(e) => {
                                f.debug_tuple("Types::StringType").field(e).finish()
                            }
                        }
                    }
                }
                #[derive(Clone)]
                pub enum Level {
                    Trace(_rt::String),
                    Debug(_rt::String),
                    Info(_rt::String),
                    Warn(_rt::String),
                    Error(_rt::String),
                }
                impl ::core::fmt::Debug for Level {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Level::Trace(e) => f.debug_tuple("Level::Trace").field(e).finish(),
                            Level::Debug(e) => f.debug_tuple("Level::Debug").field(e).finish(),
                            Level::Info(e) => f.debug_tuple("Level::Info").field(e).finish(),
                            Level::Warn(e) => f.debug_tuple("Level::Warn").field(e).finish(),
                            Level::Error(e) => f.debug_tuple("Level::Error").field(e).finish(),
                        }
                    }
                }
                #[derive(Clone)]
                pub enum GuestToHost {
                    Input,
                    Random(Types),
                    Time,
                    HttpRequest(Request),
                    Log(Level),
                }
                impl ::core::fmt::Debug for GuestToHost {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            GuestToHost::Input => f.debug_tuple("GuestToHost::Input").finish(),
                            GuestToHost::Random(e) => {
                                f.debug_tuple("GuestToHost::Random").field(e).finish()
                            }
                            GuestToHost::Time => f.debug_tuple("GuestToHost::Time").finish(),
                            GuestToHost::HttpRequest(e) => {
                                f.debug_tuple("GuestToHost::HttpRequest").field(e).finish()
                            }
                            GuestToHost::Log(e) => {
                                f.debug_tuple("GuestToHost::Log").field(e).finish()
                            }
                        }
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct SystemTime {
                    pub tv_sec: u64,
                    pub tv_nsec: u32,
                }
                impl ::core::fmt::Debug for SystemTime {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("SystemTime")
                            .field("tv-sec", &self.tv_sec)
                            .field("tv-nsec", &self.tv_nsec)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub enum Content {
                    Unit,
                    Random(Types),
                    Value(Types),
                    HttpResponse(Result<Response, Error>),
                    Time(SystemTime),
                }
                impl ::core::fmt::Debug for Content {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            Content::Unit => f.debug_tuple("Content::Unit").finish(),
                            Content::Random(e) => {
                                f.debug_tuple("Content::Random").field(e).finish()
                            }
                            Content::Value(e) => f.debug_tuple("Content::Value").field(e).finish(),
                            Content::HttpResponse(e) => {
                                f.debug_tuple("Content::HttpResponse").field(e).finish()
                            }
                            Content::Time(e) => f.debug_tuple("Content::Time").field(e).finish(),
                        }
                    }
                }
                #[derive(Clone)]
                pub struct HostToGuest {
                    pub id: _rt::String,
                    pub content: Content,
                }
                impl ::core::fmt::Debug for HostToGuest {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("HostToGuest")
                            .field("id", &self.id)
                            .field("content", &self.content)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct WorkflowError {
                    pub id: Option<_rt::String>,
                    pub error: _rt::String,
                }
                impl ::core::fmt::Debug for WorkflowError {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("WorkflowError")
                            .field("id", &self.id)
                            .field("error", &self.error)
                            .finish()
                    }
                }
                impl ::core::fmt::Display for WorkflowError {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        write!(f, "{:?}", self)
                    }
                }
                impl std::error::Error for WorkflowError {}
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_component_workflow_abi_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _: () = {};
                    };
                }
                #[doc(hidden)]
                pub use __export_component_workflow_abi_cabi;
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }

    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }

    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }

    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }

    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }

    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }

    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
#[macro_export]
macro_rules! __export_workflow_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_workflow_cabi!($ty with_types_in $($path_to_types_root)*);
  $($path_to_types_root)*::exports::component::workflow::http::__export_component_workflow_http_cabi!($ty with_types_in $($path_to_types_root)*::exports::component::workflow::http);
  $($path_to_types_root)*::exports::component::workflow::abi::__export_component_workflow_abi_cabi!($ty with_types_in $($path_to_types_root)*::exports::component::workflow::abi);
  const _: () = {

    #[cfg(target_arch = "wasm32")]
    #[link_section = "component-type:wit-bindgen:0.25.0:workflow:imports and exports"]
    #[doc(hidden)]
    pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2132] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd5\x0f\x01A\x02\x01\
A\x16\x01B\x14\x01m\x03\x03get\x04post\x06delete\x04\0\x06method\x03\0\0\x01r\x02\
\x03keys\x05values\x04\0\x06header\x03\0\x02\x01p}\x01k\x04\x01p\x03\x01r\x04\x06\
method\x01\x04body\x05\x04paths\x07headers\x06\x04\0\x07request\x03\0\x07\x01q\x05\
\x0ehttp-zero-nine\0\0\x0dhttp-one-zero\0\0\x0chttp-one-one\0\0\x0dhttp-two-zero\
\0\0\x0fhttp-three-zero\0\0\x04\0\x07version\x03\0\x09\x01kw\x01r\x06\x06status{\
\x0chttp-version\x0a\x07headers\x06\x0econtent-length\x0b\x03urls\x04body\x04\x04\
\0\x08response\x03\0\x0c\x01q\x07\x07builder\0\0\x07request\0\0\x08redirect\0\0\x06\
status\x01{\0\x04body\0\0\x06decode\0\0\x07upgrade\0\0\x04\0\x04kind\x03\0\x0e\x01\
ks\x01k\x0f\x01r\x02\x03url\x10\x04kind\x11\x04\0\x05error\x03\0\x12\x03\x01\x17\
component:workflow/http\x05\0\x02\x03\0\0\x07request\x02\x03\0\0\x08response\x02\
\x03\0\0\x05error\x01B\x16\x02\x03\x02\x01\x01\x04\0\x07request\x03\0\0\x02\x03\x02\
\x01\x02\x04\0\x08response\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x05error\x03\0\x04\
\x01q\x04\x09bool-type\x01\x7f\0\x08i32-type\x01y\0\x08f32-type\x01v\0\x0bstring\
-type\x01s\0\x04\0\x05types\x03\0\x06\x01q\x05\x05trace\x01s\0\x05debug\x01s\0\x04\
info\x01s\0\x04warn\x01s\0\x05error\x01s\0\x04\0\x05level\x03\0\x08\x01q\x05\x05\
input\0\0\x06random\x01\x07\0\x04time\0\0\x0chttp-request\x01\x01\0\x03log\x01\x09\
\0\x04\0\x0dguest-to-host\x03\0\x0a\x01r\x02\x06tv-secw\x07tv-nsecy\x04\0\x0bsys\
tem-time\x03\0\x0c\x01j\x01\x03\x01\x05\x01q\x05\x04unit\0\0\x06random\x01\x07\0\
\x05value\x01\x07\0\x0dhttp-response\x01\x0e\0\x04time\x01\x0d\0\x04\0\x07conten\
t\x03\0\x0f\x01r\x02\x02ids\x07content\x10\x04\0\x0dhost-to-guest\x03\0\x11\x01k\
s\x01r\x02\x02id\x13\x05errors\x04\0\x0eworkflow-error\x03\0\x14\x03\x01\x16comp\
onent:workflow/abi\x05\x04\x02\x03\0\x01\x0dguest-to-host\x03\0\x0dguest-to-host\
\x03\0\x05\x02\x03\0\x01\x0dhost-to-guest\x03\0\x0dhost-to-guest\x03\0\x07\x02\x03\
\0\x01\x0eworkflow-error\x03\0\x0eworkflow-error\x03\0\x09\x01@\x01\x05input\x06\
\0\x08\x03\0\x04call\x01\x0b\x01j\0\x01\x0a\x01@\0\0\x0c\x04\0\x07execute\x01\x0d\
\x01B\x14\x01m\x03\x03get\x04post\x06delete\x04\0\x06method\x03\0\0\x01r\x02\x03\
keys\x05values\x04\0\x06header\x03\0\x02\x01p}\x01k\x04\x01p\x03\x01r\x04\x06met\
hod\x01\x04body\x05\x04paths\x07headers\x06\x04\0\x07request\x03\0\x07\x01q\x05\x0e\
http-zero-nine\0\0\x0dhttp-one-zero\0\0\x0chttp-one-one\0\0\x0dhttp-two-zero\0\0\
\x0fhttp-three-zero\0\0\x04\0\x07version\x03\0\x09\x01kw\x01r\x06\x06status{\x0c\
http-version\x0a\x07headers\x06\x0econtent-length\x0b\x03urls\x04body\x04\x04\0\x08\
response\x03\0\x0c\x01q\x07\x07builder\0\0\x07request\0\0\x08redirect\0\0\x06sta\
tus\x01{\0\x04body\0\0\x06decode\0\0\x07upgrade\0\0\x04\0\x04kind\x03\0\x0e\x01k\
s\x01k\x0f\x01r\x02\x03url\x10\x04kind\x11\x04\0\x05error\x03\0\x12\x04\x01\x17c\
omponent:workflow/http\x05\x0e\x01B\x16\x02\x03\x02\x01\x01\x04\0\x07request\x03\
\0\0\x02\x03\x02\x01\x02\x04\0\x08response\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x05\
error\x03\0\x04\x01q\x04\x09bool-type\x01\x7f\0\x08i32-type\x01y\0\x08f32-type\x01\
v\0\x0bstring-type\x01s\0\x04\0\x05types\x03\0\x06\x01q\x05\x05trace\x01s\0\x05d\
ebug\x01s\0\x04info\x01s\0\x04warn\x01s\0\x05error\x01s\0\x04\0\x05level\x03\0\x08\
\x01q\x05\x05input\0\0\x06random\x01\x07\0\x04time\0\0\x0chttp-request\x01\x01\0\
\x03log\x01\x09\0\x04\0\x0dguest-to-host\x03\0\x0a\x01r\x02\x06tv-secw\x07tv-nse\
cy\x04\0\x0bsystem-time\x03\0\x0c\x01j\x01\x03\x01\x05\x01q\x05\x04unit\0\0\x06r\
andom\x01\x07\0\x05value\x01\x07\0\x0dhttp-response\x01\x0e\0\x04time\x01\x0d\0\x04\
\0\x07content\x03\0\x0f\x01r\x02\x02ids\x07content\x10\x04\0\x0dhost-to-guest\x03\
\0\x11\x01ks\x01r\x02\x02id\x13\x05errors\x04\0\x0eworkflow-error\x03\0\x14\x04\x01\
\x16component:workflow/abi\x05\x0f\x04\x01\x1bcomponent:workflow/workflow\x04\0\x0b\
\x0e\x01\0\x08workflow\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-co\
mponent\x070.208.1\x10wit-bindgen-rust\x060.25.0";
  };
  )
}
#[doc(inline)]
pub use __export_workflow_impl as export;

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
